<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>AI Particle Shaper - Fixed</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', sans-serif; }
  
  /* --- FIXED: Video Visibility --- */
  /* We do NOT use display: none here. We use opacity 0 and push it to the back.
     This ensures the browser keeps decoding frames for the AI. */
  .input_video { 
    position: absolute; 
    top: 0; left: 0; 
    width: 1px; height: 1px; 
    opacity: 0; 
    pointer-events: none; 
    z-index: -1;
  }

  /* --- UI Controls --- */
  #controls {
    position: absolute; top: 20px; left: 20px;
    z-index: 30; display: flex; flex-direction: column; gap: 12px;
  }

  .mode-row, .settings-row {
    display: flex; gap: 8px; align-items: center;
  }

  .settings-row {
    background: rgba(20,20,20,0.7);
    padding: 10px; border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.1);
    backdrop-filter: blur(10px);
  }

  .btn {
    padding: 10px 16px; border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.1);
    background: rgba(40,40,40,0.6);
    color: white; cursor: pointer;
    font-size: 0.9rem; transition: 0.2s;
    backdrop-filter: blur(4px);
  }
  .btn:hover { background: rgba(255,255,255,0.2); }
  .btn.active { 
    background: #6c5ce7; border-color: #6c5ce7; 
    box-shadow: 0 0 15px rgba(108, 92, 231, 0.4); 
  }

  input[type="color"] {
    width: 35px; height: 35px; border: none; background: none; cursor: pointer;
  }
  input[type="range"] { accent-color: #6c5ce7; cursor: pointer; }
  label { font-size: 0.8rem; color: #ccc; }

  /* --- Status & Overlay --- */
  #status-pill {
    position: absolute; top: 20px; right: 20px;
    background: rgba(20,20,20,0.8); padding: 8px 16px;
    border-radius: 20px; color: #aaa; font-size: 0.85rem;
    border: 1px solid rgba(255,255,255,0.1);
    pointer-events: none; transition: 0.3s;
  }
  #status-pill.active { color: #6c5ce7; border-color: #6c5ce7; box-shadow: 0 0 10px rgba(108,92,231,0.2); }

  #overlay {
    position: absolute; bottom: 30px; width: 100%;
    text-align: center; color: rgba(255,255,255,0.6);
    pointer-events: none;
  }
  #overlay h2 { margin: 0 0 5px 0; font-weight: 300; text-transform: uppercase; letter-spacing: 2px; }
  #overlay p { font-size: 0.9rem; }
  .emoji-guide { font-size: 1.5rem; letter-spacing: 10px; margin-top: 10px; display: block; filter: grayscale(1); opacity: 0.5; }
</style>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
</script>
</head>
<body>

<video class="input_video" playsinline muted autoplay></video>

<div id="controls">
  <div class="mode-row">
    <button id="btnAI" class="btn active">ü§ñ AI Detect</button>
    <button id="btnCam" class="btn">üìπ Live Mirror</button>
    <button id="btnImg" class="btn">üñºÔ∏è Image</button>
    <input type="file" id="fileInput" accept="image/*" hidden>
  </div>
  
  <div class="settings-row">
    <label>Color</label>
    <input type="color" id="colorPicker" value="#6c5ce7">
    <label>Glow</label>
    <input type="range" id="brightSlider" min="0.5" max="3" step="0.1" value="1.2">
    <button id="btnCap" class="btn" title="Screenshot">üì∑</button>
  </div>
</div>

<div id="status-pill">System Initializing...</div>

<div id="overlay">
  <h2 id="modeTitle">AI Mode</h2>
  <p id="modeDesc">I will mimic your hand gestures with particles.</p>
  <div class="emoji-guide">üëç ‚úåÔ∏è ‚úã üëä ‚ù§Ô∏è ü§ò</div>
</div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

/* ================= CONFIGURATION ================= */
const CONFIG = {
  COUNT: 30000,
  SIZE: 0.22,
  LERP: 0.08,
  
  // Resolution for Emoji/Image sampling
  CANVAS_W: 150, 
  CANVAS_H: 150,
  
  // Camera Mode
  CAM_FPS: 30,
  MIN_LUMA: 0.1,
  DEPTH_AMT: 8.0
};

// Global State
const state = {
  mode: 'ai', // 'ai', 'camera', 'image'
  currentGesture: 'cloud', // 'cloud', 'thumbs_up', 'victory', etc.
  
  // Buffers
  targetPos: new Float32Array(CONFIG.COUNT * 3),
  targetCol: new Float32Array(CONFIG.COUNT * 3),
  
  // User Settings
  userColor: new THREE.Color('#6c5ce7'),
  brightness: 1.2,
  
  // Internals
  camTimer: null,
  handsReady: false
};

/* ================= THREE.JS SETUP ================= */
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x050505, 0.015);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
camera.position.z = 40;

const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.rotateSpeed = 0.5;

/* ================= PARTICLE SYSTEM ================= */
const geo = new THREE.BufferGeometry();
const pos = new Float32Array(CONFIG.COUNT * 3);
const col = new Float32Array(CONFIG.COUNT * 3);

// Initialize Random Cloud
for(let i=0; i<CONFIG.COUNT; i++) {
  pos[i*3] = (Math.random()-0.5)*50;
  pos[i*3+1] = (Math.random()-0.5)*50;
  pos[i*3+2] = (Math.random()-0.5)*50;
  
  state.targetPos[i*3] = pos[i*3];
  state.targetPos[i*3+1] = pos[i*3+1];
  state.targetPos[i*3+2] = pos[i*3+2];
  
  // Default color
  col[i*3] = state.userColor.r; 
  col[i*3+1] = state.userColor.g; 
  col[i*3+2] = state.userColor.b;
}

geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
geo.setAttribute('color', new THREE.BufferAttribute(col, 3));

// Texture
const canvas = document.createElement('canvas'); canvas.width=32; canvas.height=32;
const ctx = canvas.getContext('2d');
const grad = ctx.createRadialGradient(16,16,0,16,16,16);
grad.addColorStop(0, 'rgba(255,255,255,1)');
grad.addColorStop(1, 'rgba(0,0,0,0)');
ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
const texture = new THREE.CanvasTexture(canvas);

const mat = new THREE.PointsMaterial({
  size: CONFIG.SIZE, map: texture,
  vertexColors: true, blending: THREE.AdditiveBlending,
  depthWrite: false, transparent: true
});
const particles = new THREE.Points(geo, mat);
scene.add(particles);

/* ================= EMOJI & SHAPE ENGINE ================= */
function generateShapeFromText(char) {
    const w = CONFIG.CANVAS_W; const h = CONFIG.CANVAS_H;
    const c = document.createElement('canvas'); c.width = w; c.height = h;
    const cx = c.getContext('2d');
    
    cx.font = 'bold 100px Arial';
    cx.textAlign = 'center';
    cx.textBaseline = 'middle';
    cx.fillStyle = 'white';
    cx.fillText(char, w/2, h/2);
    
    const data = cx.getImageData(0,0,w,h).data;
    const validPixels = [];
    
    // Scan for pixels
    for(let y=0; y<h; y+=2) { // Skip every other pixel for density control
        for(let x=0; x<w; x+=2) {
            const idx = (y*w + x)*4;
            if(data[idx+3] > 128) { // If not transparent
                validPixels.push({
                    x: (x - w/2) * 0.35,
                    y: -(y - h/2) * 0.35,
                    z: 0
                });
            }
        }
    }
    
    // Assign to particles
    const indices = Array.from({length: CONFIG.COUNT}, (_,i)=>i).sort(()=>Math.random()-0.5);
    let pixelIdx = 0;
    
    for(let i=0; i<CONFIG.COUNT; i++) {
        const pIdx = indices[i];
        const idx3 = pIdx * 3;
        
        if(pixelIdx < validPixels.length) {
            const p = validPixels[pixelIdx];
            state.targetPos[idx3] = p.x;
            state.targetPos[idx3+1] = p.y;
            state.targetPos[idx3+2] = p.z;
            pixelIdx++;
        } else {
            // Excess particles float in background
            const angle = Math.random()*Math.PI*2;
            const r = 25 + Math.random()*10;
            state.targetPos[idx3] = Math.cos(angle)*r;
            state.targetPos[idx3+1] = Math.sin(angle)*r;
            state.targetPos[idx3+2] = (Math.random()-0.5)*20;
        }
        
        // Update Color Target (Use User Color)
        state.targetCol[idx3] = state.userColor.r;
        state.targetCol[idx3+1] = state.userColor.g;
        state.targetCol[idx3+2] = state.userColor.b;
    }
}

function generateCloud() {
    for(let i=0; i<CONFIG.COUNT; i++) {
        const idx3 = i*3;
        const r = 30 * Math.cbrt(Math.random());
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        
        state.targetPos[idx3] = r * Math.sin(phi) * Math.cos(theta);
        state.targetPos[idx3+1] = r * Math.sin(phi) * Math.sin(theta);
        state.targetPos[idx3+2] = r * Math.cos(phi);
        
        state.targetCol[idx3] = state.userColor.r;
        state.targetCol[idx3+1] = state.userColor.g;
        state.targetCol[idx3+2] = state.userColor.b;
    }
}

/* ================= LIVE CAMERA LOGIC ================= */
const videoEl = document.querySelector('.input_video');
const camC = document.createElement('canvas');
const camCtx = camC.getContext('2d', {willReadFrequently:true});

function updateLiveCamera() {
    if(state.mode !== 'camera' || !videoEl.videoWidth) return;
    
    const h = 130; // Resolution
    const w = Math.floor(h * (videoEl.videoWidth/videoEl.videoHeight));
    camC.width=w; camC.height=h;
    
    // Draw flipped for mirror effect (scale x -1)
    camCtx.save();
    camCtx.scale(-1, 1);
    camCtx.drawImage(videoEl, -w, 0, w, h);
    camCtx.restore();
    
    const data = camCtx.getImageData(0,0,w,h).data;
    const totalPixels = w*h;
    
    // Stable random mapping
    if(!state.camOrder || state.camOrder.length !== totalPixels) {
        state.camOrder = new Uint32Array(totalPixels);
        for(let i=0; i<totalPixels; i++) state.camOrder[i] = i;
        for(let i=totalPixels-1; i>0; i--) {
            const j = Math.floor(Math.random()*(i+1));
            [state.camOrder[i], state.camOrder[j]] = [state.camOrder[j], state.camOrder[i]];
        }
    }
    
    let used = 0;
    for(let i=0; i<totalPixels && used<CONFIG.COUNT; i++) {
        const pIdx = state.camOrder[i];
        const r = data[i*4]/255;
        const g = data[i*4+1]/255;
        const b = data[i*4+2]/255;
        const luma = (r+g+b)/3;
        
        if(luma < CONFIG.MIN_LUMA) continue;
        
        const x = i % w; const y = Math.floor(i/w);
        const idx3 = pIdx*3;
        
        state.targetPos[idx3] = (x - w/2) * 0.35;
        state.targetPos[idx3+1] = -(y - h/2) * 0.35;
        state.targetPos[idx3+2] = (luma - 0.5) * CONFIG.DEPTH_AMT; // 3D Depth
        
        // In Camera mode, we use the actual camera colors
        state.targetCol[idx3] = r; 
        state.targetCol[idx3+1] = g; 
        state.targetCol[idx3+2] = b;
        
        used++;
    }
    
    // Hide rest
    for(let k=used; k<CONFIG.COUNT; k++) {
        state.targetPos[state.camOrder? state.camOrder[k]*3 : k*3] = 1000;
    }
}

/* ================= AI GESTURE RECOGNITION ================= */
// Simple rule-based recognizer
function detectGesture(landmarks) {
    const isExtended = (hand, fingerTip, fingerPip) => {
        return Math.hypot(hand[fingerTip].x - hand[0].x, hand[fingerTip].y - hand[0].y) > 
               Math.hypot(hand[fingerPip].x - hand[0].x, hand[fingerPip].y - hand[0].y);
    };

    // 1. Check for Heart (Two hands needed)
    if(landmarks.length === 2) {
        const h1 = landmarks[0]; const h2 = landmarks[1];
        const idxDist = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
        const thumbDist = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);
        if(idxDist < 0.15 && thumbDist < 0.15) return 'heart';
    }

    // 2. Single Hand Gestures (Take the first hand)
    const h = landmarks[0];
    const thumbExt = isExtended(h, 4, 2);
    const indexExt = isExtended(h, 8, 6);
    const midExt = isExtended(h, 12, 10);
    const ringExt = isExtended(h, 16, 14);
    const pinkyExt = isExtended(h, 20, 18);

    if (thumbExt && !indexExt && !midExt && !ringExt && !pinkyExt) return 'thumbs_up';
    if (!thumbExt && indexExt && midExt && !ringExt && !pinkyExt) return 'victory';
    if (!thumbExt && indexExt && !midExt && !ringExt && pinkyExt) return 'rock';
    if (!thumbExt && !indexExt && !midExt && !ringExt && !pinkyExt) return 'fist';
    if (indexExt && midExt && ringExt && pinkyExt) return 'open';
    
    return 'cloud';
}

// MediaPipe Setup
const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({maxNumHands: 2, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});

hands.onResults((r) => {
    if(!state.handsReady) {
        state.handsReady = true;
        document.getElementById('status-pill').textContent = "Camera Ready";
    }

    if(state.mode === 'ai') {
        let detected = 'cloud';
        if(r.multiHandLandmarks && r.multiHandLandmarks.length > 0) {
            detected = detectGesture(r.multiHandLandmarks);
        }
        
        if(detected !== state.currentGesture) {
            state.currentGesture = detected;
            
            // Trigger Shape Change
            const pill = document.getElementById('status-pill');
            
            switch(detected) {
                case 'thumbs_up': 
                    generateShapeFromText('üëç'); 
                    pill.textContent = "Detected: Thumbs Up";
                    break;
                case 'victory': 
                    generateShapeFromText('‚úåÔ∏è'); 
                    pill.textContent = "Detected: Victory";
                    break;
                case 'open': 
                    generateShapeFromText('‚úã'); 
                    pill.textContent = "Detected: Open Hand";
                    break;
                case 'fist': 
                    generateShapeFromText('üëä'); 
                    pill.textContent = "Detected: Fist";
                    break;
                case 'heart': 
                    generateShapeFromText('‚ù§Ô∏è'); 
                    pill.textContent = "Detected: Heart";
                    break;
                case 'rock': 
                    generateShapeFromText('ü§ò'); 
                    pill.textContent = "Detected: Rock On";
                    break;
                default: 
                    generateCloud(); 
                    pill.textContent = "Waiting for gesture...";
            }
            pill.classList.add('active');
            setTimeout(()=>pill.classList.remove('active'), 500);
        }
    }
});


/* ================= UI & LOGIC ================= */
const statusPill = document.getElementById('status-pill');
const colorPicker = document.getElementById('colorPicker');

// Color Logic
colorPicker.addEventListener('input', (e) => {
    state.userColor.set(e.target.value);
    if(state.mode === 'ai') {
        for(let i=0; i<CONFIG.COUNT; i++) {
            state.targetCol[i*3] = state.userColor.r;
            state.targetCol[i*3+1] = state.userColor.g;
            state.targetCol[i*3+2] = state.userColor.b;
        }
    }
});

document.getElementById('brightSlider').addEventListener('input', (e) => {
    state.brightness = parseFloat(e.target.value);
});

// FIXED: Mode Switching
const setMode = (m) => {
    state.mode = m;
    clearInterval(state.camTimer);
    
    document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
    
    const title = document.getElementById('modeTitle');
    const desc = document.getElementById('modeDesc');
    const guide = document.querySelector('.emoji-guide');

    if(m === 'ai') {
        document.getElementById('btnAI').classList.add('active');
        title.innerText = "AI Mode";
        desc.innerText = "Make a gesture (üëç ‚úåÔ∏è ‚úã üëä ‚ù§Ô∏è ü§ò)";
        guide.style.display = "block";
        controls.reset();
        camera.position.z = 40;
        generateCloud();
        
        // Kickstart the manual loop
        runAIDetection();
    } else if (m === 'camera') {
        document.getElementById('btnCam').classList.add('active');
        title.innerText = "Live Mirror";
        desc.innerText = "You are the particles.";
        guide.style.display = "none";
        state.camTimer = setInterval(updateLiveCamera, 1000/CONFIG.CAM_FPS);
    } else if (m === 'image') {
        document.getElementById('btnImg').classList.add('active');
        document.getElementById('fileInput').click();
        title.innerText = "Image Mode";
        desc.innerText = "Static Reconstruction";
        guide.style.display = "none";
    }
}

document.getElementById('btnAI').onclick = () => setMode('ai');
document.getElementById('btnCam').onclick = () => setMode('camera');
document.getElementById('btnImg').onclick = () => setMode('image');

document.getElementById('fileInput').onchange = (e) => {
    if(!e.target.files[0]) return;
    const url = URL.createObjectURL(e.target.files[0]);
    const img = new Image();
    img.onload = () => {
        const c = document.createElement('canvas');
        const r = CONFIG.CANVAS_W / img.width;
        c.width = CONFIG.CANVAS_W; c.height = img.height * r;
        const cx = c.getContext('2d'); cx.drawImage(img, 0, 0, c.width, c.height);
        const data = cx.getImageData(0,0,c.width,c.height).data;
        
        const indices = Array.from({length: CONFIG.COUNT}, (_,i)=>i).sort(()=>Math.random()-0.5);
        let used = 0;
        for(let i=0; i<c.width*c.height && used<CONFIG.COUNT; i++) {
            const r=data[i*4]/255, g=data[i*4+1]/255, b=data[i*4+2]/255, a=data[i*4+3];
            if(a>128) {
                const idx = indices[used];
                const x = i%c.width; const y = Math.floor(i/c.width);
                state.targetPos[idx*3] = (x - c.width/2)*0.35;
                state.targetPos[idx*3+1] = -(y - c.height/2)*0.35;
                state.targetPos[idx*3+2] = 0;
                
                state.targetCol[idx*3] = r; state.targetCol[idx*3+1] = g; state.targetCol[idx*3+2] = b;
                used++;
            }
        }
        for(let k=used; k<CONFIG.COUNT; k++) state.targetPos[indices[k]*3] = 1000;
        document.getElementById('btnImg').classList.add('active');
    };
    img.src = url;
};

document.getElementById('btnCap').onclick = () => {
    renderer.render(scene, camera);
    const a = document.createElement('a');
    a.download = 'particles_ai.png';
    a.href = renderer.domElement.toDataURL('image/png');
    a.click();
};

/* ================= CAMERA STARTUP & LOOPS ================= */

// 1. Initialize Camera (Just to start the stream)
const camObj = new Camera(videoEl, {
    onFrame: async () => {}, // We do not use this loop.
    width: 640, height: 480
});
camObj.start();

// 2. Manual AI Loop (Decoupled from Camera Utility)
let isDetecting = false;
async function runAIDetection() {
    if(state.mode === 'ai' && videoEl.readyState === 4 && !isDetecting) {
        isDetecting = true;
        try { await hands.send({image: videoEl}); } 
        catch(e) { console.error(e); }
        isDetecting = false;
    }
    if(state.mode === 'ai') {
        setTimeout(() => requestAnimationFrame(runAIDetection), 30);
    }
}

// 3. Animation Loop
function animate() {
    requestAnimationFrame(animate);
    controls.update();
    
    const brightness = state.brightness;
    const posAttr = geo.attributes.position;
    const colAttr = geo.attributes.color;

    for(let i=0; i<CONFIG.COUNT; i++) {
        const idx3 = i*3;
        
        pos[idx3] += (state.targetPos[idx3] - pos[idx3]) * CONFIG.LERP;
        pos[idx3+1] += (state.targetPos[idx3+1] - pos[idx3+1]) * CONFIG.LERP;
        pos[idx3+2] += (state.targetPos[idx3+2] - pos[idx3+2]) * CONFIG.LERP;
        
        col[idx3] += (state.targetCol[idx3] - col[idx3]) * 0.1;
        col[idx3+1] += (state.targetCol[idx3+1] - col[idx3+1]) * 0.1;
        col[idx3+2] += (state.targetCol[idx3+2] - col[idx3+2]) * 0.1;
        
        colAttr.array[idx3] = Math.min(1, col[idx3] * brightness);
        colAttr.array[idx3+1] = Math.min(1, col[idx3+1] * brightness);
        colAttr.array[idx3+2] = Math.min(1, col[idx3+2] * brightness);
    }
    
    posAttr.needsUpdate = true;
    colAttr.needsUpdate = true;
    
    renderer.render(scene, camera);
}

// Start
if(state.mode === 'ai') runAIDetection();
animate();

window.onresize = () => {
    camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
};
</script>
</body>
</html>
