<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Interactive Particles</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
  body { margin: 0; overflow: hidden; background: #050505; font-family: system-ui, sans-serif; }
  .input_video { display: none; }

  /* UI Container */
  #controls {
    position: absolute; top: 20px; left: 20px;
    z-index: 20; display: flex; gap: 10px; flex-wrap: wrap;
  }

  .btn {
    padding: 10px 16px;
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.15);
    background: rgba(255,255,255,0.05);
    color: white; cursor: pointer;
    user-select: none;
    font-size: 0.9rem;
    backdrop-filter: blur(4px);
    transition: all 0.2s;
  }
  .btn:hover { background: rgba(255,255,255,0.2); }
  .btn.active { 
    background: #ff4757; 
    border-color: #ff4757; 
    box-shadow: 0 0 15px rgba(255, 71, 87, 0.4);
  }

  /* Status Indicator */
  #status {
    position: absolute; top: 20px; right: 20px;
    color: #ccc; padding: 8px 16px;
    background: rgba(20,20,20,0.8);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 20px;
    z-index: 20;
    font-size: 0.85rem;
    pointer-events: none;
  }

  /* Bottom Overlay */
  #overlay {
    position: absolute; bottom: 30px; width: 100%;
    text-align: center; color: rgba(255,255,255,0.6);
    z-index: 10; pointer-events: none;
  }
  #overlay h2 { margin: 0 0 8px 0; font-weight: 300; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 2px; }
  #overlay p { margin: 0; font-size: 0.95rem; }
  .highlight { color: #ff4757; font-weight: bold; }
  .hint { font-size: 0.8rem; opacity: 0.7; margin-top: 5px; display: block; }
</style>

<!-- MediaPipe Dependencies -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

<!-- Three.js with Addons (OrbitControls) -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>

<body>

<video class="input_video" playsinline></video>

<div id="controls">
  <button id="btnGesture" class="btn active">üëê Gesture Mode</button>
  <button id="btnUpload"  class="btn">üñºÔ∏è Upload Image</button>
  <button id="btnCamera"  class="btn">üìπ Camera Mode</button>
  <input type="file" id="fileInput" accept="image/*" hidden>
</div>

<div id="status">Initializing System...</div>

<div id="overlay">
  <h2 id="modeTitle">Gesture Mode</h2>
  <p id="modeDesc">Make a <span class="highlight">Heart ü´∂</span> with both hands.</p>
  <span class="hint">üñ±Ô∏è Click & Drag to Rotate | Scroll to Zoom</span>
</div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

/* ================= CONFIGURATION ================= */
const CONFIG = {
  COUNT: 32000,           // Increased count for denser camera view
  SIZE: 0.20,             // Slightly larger particles to fill gaps
  LERP: 0.08,             // Animation smoothing

  HEART_COLOR: new THREE.Color(0xff0044),
  CLOUD_COLOR: new THREE.Color(0x00aaff),

  // Camera/Image Mode Settings
  SAMPLE_H: 130,          // Vertical resolution sample size
  CAMERA_FPS: 24,         // Higher update rate
  DEPTH_SCALE: 10.0,      // Depth pop
  SPREAD_SCALE: 0.35,     // How spread out the camera pixels are (0.35 fills screen better than 0.15)
  MIN_LUMA: 0.08          
};

/* ================= STATE ================= */
const state = {
  mode: "gesture", // 'gesture', 'image', 'camera'
  heart: false,

  imageReady: false,
  imagePos: new Float32Array(CONFIG.COUNT * 3),
  imageCol: new Float32Array(CONFIG.COUNT * 3),

  // Buffers for Camera Mode
  camPos: new Float32Array(CONFIG.COUNT * 3),
  camCol: new Float32Array(CONFIG.COUNT * 3),
  camParticleOrder: null, 
  camTimer: null
};

/* ================= THREE.JS SETUP ================= */
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x050505, 0.015); // Lighter fog for better visibility at distance

const camera3D = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
camera3D.position.z = 40; // Pulled back slightly to fit the larger camera view

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

// --- ADD ORBIT CONTROLS ---
const controls = new OrbitControls(camera3D, renderer.domElement);
controls.enableDamping = true; // Smooth motion
controls.dampingFactor = 0.05;
controls.enablePan = true;
controls.rotateSpeed = 0.5;

/* ================= PARTICLES SYSTEM ================= */
const geo = new THREE.BufferGeometry();
const pos = new Float32Array(CONFIG.COUNT * 3);
const targetPos = new Float32Array(CONFIG.COUNT * 3);
const col = new Float32Array(CONFIG.COUNT * 3);
const targetCol = new Float32Array(CONFIG.COUNT * 3);

// Create soft glow texture
function makeSpriteTexture() {
  const c = document.createElement("canvas");
  c.width = c.height = 32;
  const g = c.getContext("2d");
  const grad = g.createRadialGradient(16,16,0,16,16,16);
  grad.addColorStop(0, "rgba(255,255,255,1)");
  grad.addColorStop(1, "rgba(0,0,0,0)");
  g.fillStyle = grad;
  g.fillRect(0,0,32,32);
  return new THREE.CanvasTexture(c);
}

// Initialize Cloud
for (let i = 0; i < CONFIG.COUNT; i++) {
  pos[i*3] = (Math.random() - 0.5) * 60;
  pos[i*3+1] = (Math.random() - 0.5) * 60;
  pos[i*3+2] = (Math.random() - 0.5) * 60;

  targetPos[i*3] = pos[i*3];
  targetPos[i*3+1] = pos[i*3+1];
  targetPos[i*3+2] = pos[i*3+2];

  col[i*3] = CONFIG.CLOUD_COLOR.r;
  col[i*3+1] = CONFIG.CLOUD_COLOR.g;
  col[i*3+2] = CONFIG.CLOUD_COLOR.b;
  
  targetCol[i*3] = col[i*3];
  targetCol[i*3+1] = col[i*3+1];
  targetCol[i*3+2] = col[i*3+2];
}

geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
geo.setAttribute("color", new THREE.BufferAttribute(col, 3));

const mat = new THREE.PointsMaterial({
  size: CONFIG.SIZE,
  map: makeSpriteTexture(),
  vertexColors: true,
  blending: THREE.AdditiveBlending,
  depthWrite: false,
  transparent: true
});

const points = new THREE.Points(geo, mat);
scene.add(points);

/* ================= SHAPE LOGIC ================= */
function cloudPoint() {
  const r = 25 * Math.cbrt(Math.random());
  const t = Math.random() * Math.PI * 2;
  const p = Math.acos(2 * Math.random() - 1);
  return {
    x: r * Math.sin(p) * Math.cos(t),
    y: r * Math.sin(p) * Math.sin(t),
    z: r * Math.cos(p)
  };
}

function heartPoint(u, v) {
  const t = u * Math.PI * 2;
  // Scaled up heart slightly to match new camera zoom
  const x = 14 * Math.pow(Math.sin(t), 3);
  const y = 12 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
  const z = (v - 0.5) * 5;
  return { x: x * 0.8, y: y * 0.8, z: z };
}

function genCloudTargets() {
  for (let i = 0; i < CONFIG.COUNT; i++) {
    const p = cloudPoint();
    targetPos[i*3] = p.x; targetPos[i*3+1] = p.y; targetPos[i*3+2] = p.z;
    targetCol[i*3] = CONFIG.CLOUD_COLOR.r;
    targetCol[i*3+1] = CONFIG.CLOUD_COLOR.g;
    targetCol[i*3+2] = CONFIG.CLOUD_COLOR.b;
  }
}

function genHeartTargets() {
  for (let i = 0; i < CONFIG.COUNT; i++) {
    const p = heartPoint(i / CONFIG.COUNT, Math.random());
    targetPos[i*3] = p.x + (Math.random()-0.5);
    targetPos[i*3+1] = p.y + (Math.random()-0.5);
    targetPos[i*3+2] = p.z + (Math.random()-0.5);
    
    targetCol[i*3] = CONFIG.HEART_COLOR.r;
    targetCol[i*3+1] = CONFIG.HEART_COLOR.g;
    targetCol[i*3+2] = CONFIG.HEART_COLOR.b;
  }
}

function genImageTargets() {
  targetPos.set(state.imagePos);
  targetCol.set(state.imageCol);
}

/* ================= IMAGE & CAMERA PROCESSING ================= */
const videoEl = document.querySelector(".input_video");
const camCanvas = document.createElement("canvas");
const camCtx = camCanvas.getContext("2d", { willReadFrequently: true });

function processImage(file) {
  statusDiv.textContent = "Processing image...";
  const img = new Image();
  img.onload = () => {
    const h = CONFIG.SAMPLE_H;
    const w = Math.floor(h * (img.width / img.height));
    const canvas = document.createElement("canvas");
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0, w, h);
    const data = ctx.getImageData(0, 0, w, h).data;
    
    // Shuffle indices 
    const order = Array.from({length: CONFIG.COUNT}, (_, i) => i).sort(() => Math.random()-0.5);
    
    let used = 0;
    for(let i=0; i<w*h && used<CONFIG.COUNT; i++) {
        const r = data[i*4]/255, g = data[i*4+1]/255, b = data[i*4+2]/255, a = data[i*4+3];
        if(a < 128) continue;
        
        const idx = order[used];
        const x = (i % w); const y = Math.floor(i / w);
        
        // Spread scale applied here
        state.imagePos[idx*3] = (x - w/2) * CONFIG.SPREAD_SCALE;
        state.imagePos[idx*3+1] = -(y - h/2) * CONFIG.SPREAD_SCALE;
        state.imagePos[idx*3+2] = 0;
        
        state.imageCol[idx*3] = r; state.imageCol[idx*3+1] = g; state.imageCol[idx*3+2] = b;
        used++;
    }
    
    for(let k=used; k<CONFIG.COUNT; k++) {
        const idx = order[k];
        state.imagePos[idx*3] = 2000; // Throw far away
    }
    
    state.imageReady = true;
    setMode("image");
    statusDiv.textContent = "Image Ready";
  };
  img.src = URL.createObjectURL(file);
}

function ensureCameraOrder(pixelCount) {
  if (state.camParticleOrder && state.camParticleOrder.length === pixelCount) return;
  const order = new Uint32Array(pixelCount);
  for(let i=0; i<pixelCount; i++) order[i] = i;
  for(let i=pixelCount-1; i>0; i--) {
      const j = Math.floor(Math.random() * (i+1));
      [order[i], order[j]] = [order[j], order[i]];
  }
  state.camParticleOrder = order;
}

function updateCameraTargets() {
    if(state.mode !== 'camera' || !videoEl.videoWidth) return;
    
    const h = CONFIG.SAMPLE_H;
    const w = Math.floor(h * (videoEl.videoWidth / videoEl.videoHeight));
    camCanvas.width = w; camCanvas.height = h;
    camCtx.drawImage(videoEl, 0, 0, w, h);
    const data = camCtx.getImageData(0, 0, w, h).data;
    const count = w * h;
    
    ensureCameraOrder(count);
    const order = state.camParticleOrder;
    
    let used = 0;
    const limit = Math.min(count, CONFIG.COUNT);
    
    for(let i=0; i<count && used < limit; i++) {
        const idx = order[i];
        if(idx >= CONFIG.COUNT) continue;
        
        const r = data[i*4]/255;
        const g = data[i*4+1]/255;
        const b = data[i*4+2]/255;
        const luma = (r+g+b)/3;
        
        if(luma < CONFIG.MIN_LUMA) continue;
        
        const x = i % w;
        const y = Math.floor(i / w);
        
        // --- SCALE INCREASED HERE ---
        state.camPos[idx*3] = (x - w/2) * CONFIG.SPREAD_SCALE;
        state.camPos[idx*3+1] = -(y - h/2) * CONFIG.SPREAD_SCALE;
        state.camPos[idx*3+2] = (luma - 0.5) * CONFIG.DEPTH_SCALE;
        
        state.camCol[idx*3] = r; state.camCol[idx*3+1] = g; state.camCol[idx*3+2] = b;
        used++;
    }
    
    for(let k=used; k<CONFIG.COUNT; k++) {
        state.camPos[k*3] = 2000;
    }
    
    targetPos.set(state.camPos);
    targetCol.set(state.camCol);
}

/* ================= UI LOGIC ================= */
const btnGesture = document.getElementById("btnGesture");
const btnUpload = document.getElementById("btnUpload");
const btnCamera = document.getElementById("btnCamera");
const fileInput = document.getElementById("fileInput");
const statusDiv = document.getElementById("status");
const modeTitle = document.getElementById("modeTitle");
const modeDesc = document.getElementById("modeDesc");

function setMode(m) {
    state.mode = m;
    
    [btnGesture, btnUpload, btnCamera].forEach(b => b.classList.remove('active'));
    if(m === 'gesture') btnGesture.classList.add('active');
    if(m === 'image') btnUpload.classList.add('active');
    if(m === 'camera') btnCamera.classList.add('active');
    
    if(state.camTimer) clearInterval(state.camTimer);
    
    // Reset camera position slightly when switching modes for better framing
    if(m === 'gesture') {
        controls.autoRotate = false; // Ensure no auto rotate
        controls.reset();
        camera3D.position.set(0,0,40); // Reset distance
        
        modeTitle.textContent = "Gesture Mode";
        modeDesc.innerHTML = "Make a <span class='highlight'>Heart ü´∂</span> with both hands.";
        statusDiv.style.opacity = 1;
        statusDiv.textContent = "Waiting for hands...";
        genCloudTargets();
    } else if (m === 'image') {
        modeTitle.textContent = "Image Mode";
        modeDesc.textContent = "Particles reconstruct your static image.";
        statusDiv.style.opacity = 0;
        if(state.imageReady) genImageTargets();
    } else if (m === 'camera') {
        modeTitle.textContent = "Camera Mode";
        modeDesc.textContent = "Live 3D reconstruction of webcam feed.";
        statusDiv.style.opacity = 0;
        state.camTimer = setInterval(updateCameraTargets, 1000/CONFIG.CAMERA_FPS);
    }
}

btnGesture.onclick = () => setMode('gesture');
btnCamera.onclick = () => setMode('camera');
btnUpload.onclick = () => fileInput.click();
fileInput.onchange = (e) => { if(e.target.files[0]) processImage(e.target.files[0]); };

/* ================= MEDIAPIPE ================= */
const hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
hands.setOptions({ maxNumHands: 2, minDetectionConfidence: 0.5 });
hands.onResults((r) => {
    if(state.mode !== 'gesture') return;
    
    let isHeart = false;
    if(r.multiHandLandmarks && r.multiHandLandmarks.length === 2) {
        const h1 = r.multiHandLandmarks[0];
        const h2 = r.multiHandLandmarks[1];
        const idxDist = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
        const thumbDist = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);
        if(idxDist < 0.08 && thumbDist < 0.08) isHeart = true;
    }
    
    if(isHeart !== state.heart) {
        state.heart = isHeart;
        if(isHeart) {
            statusDiv.textContent = "HEART DETECTED ‚ù§Ô∏è";
            statusDiv.style.color = "#ff4757";
            genHeartTargets();
        } else {
            statusDiv.textContent = "Hands separated";
            statusDiv.style.color = "#ccc";
            genCloudTargets();
        }
    }
});

const mpCam = new Camera(videoEl, {
    onFrame: async () => { await hands.send({image: videoEl}); },
    width: 640, height: 480
});
mpCam.start();

/* ================= LOOP ================= */
function animate() {
    requestAnimationFrame(animate);
    
    // Update OrbitControls
    controls.update();

    // Lerp positions
    for(let i=0; i<CONFIG.COUNT * 3; i++) {
        pos[i] += (targetPos[i] - pos[i]) * CONFIG.LERP;
        col[i] += (targetCol[i] - col[i]) * 0.05;
    }
    
    // Removed automatic rotation line: scene.rotation.y += ...
    
    geo.attributes.position.needsUpdate = true;
    geo.attributes.color.needsUpdate = true;
    renderer.render(scene, camera3D);
}

animate();

window.onresize = () => {
    camera3D.aspect = innerWidth/innerHeight;
    camera3D.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
};

</script>
</body>
</html>
