
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gesture & Image Particle System</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body {
    margin: 0;
    overflow: hidden;
    background: #050505;
    font-family: system-ui, sans-serif;
}
.input_video { display: none; }

#controls {
    position: absolute;
    top: 20px;
    left: 20px;
    z-index: 10;
    display: flex;
    gap: 10px;
}

.btn {
    padding: 10px 14px;
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.2);
    background: rgba(255,255,255,0.1);
    color: white;
    cursor: pointer;
}
.btn.active { background: #ff4757; border-color: #ff4757; }

#status {
    position: absolute;
    top: 20px;
    right: 20px;
    color: #aaa;
    padding: 8px 14px;
    background: rgba(20,20,20,0.8);
    border-radius: 20px;
}

#overlay {
    position: absolute;
    bottom: 30px;
    width: 100%;
    text-align: center;
    color: rgba(255,255,255,0.7);
}
</style>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>

<body>

<video class="input_video"></video>

<div id="controls">
    <button id="btnGesture" class="btn active">Gesture Mode</button>
    <button id="btnImage" class="btn">Upload Image</button>
    <input type="file" id="fileInput" accept="image/*" hidden>
</div>

<div id="status">Waiting for handsâ€¦</div>

<div id="overlay">
    <h2 id="modeTitle">Gesture Mode</h2>
    <p id="modeDesc">Make a ðŸ«¶ heart gesture</p>
</div>

<script type="module">
import * as THREE from "three";

/* ================= CONFIG ================= */
const CONFIG = {
    COUNT: 25000,
    SIZE: 0.14,
    LERP: 0.08,
    HEART_COLOR: new THREE.Color(0xff0044),
    CLOUD_COLOR: new THREE.Color(0x00aaff)
};

/* ================= STATE ================= */
const state = {
    mode: "gesture", // gesture | image
    heart: false,
    imageReady: false,
    imagePos: new Float32Array(CONFIG.COUNT * 3),
    imageCol: new Float32Array(CONFIG.COUNT * 3)
};

/* ================= THREE ================= */
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x050505, 0.02);

const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
camera.position.z = 30;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* ================= PARTICLES ================= */
const geo = new THREE.BufferGeometry();
const pos = new Float32Array(CONFIG.COUNT * 3);
const targetPos = new Float32Array(CONFIG.COUNT * 3);
const col = new Float32Array(CONFIG.COUNT * 3);
const targetCol = new Float32Array(CONFIG.COUNT * 3);

for (let i = 0; i < CONFIG.COUNT * 3; i++) {
    pos[i] = (Math.random() - 0.5) * 60;
    col[i] = CONFIG.CLOUD_COLOR.toArray()[i % 3];
}

geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
geo.setAttribute("color", new THREE.BufferAttribute(col, 3));

function sprite() {
    const c = document.createElement("canvas");
    c.width = c.height = 32;
    const g = c.getContext("2d");
    const r = g.createRadialGradient(16,16,0,16,16,16);
    r.addColorStop(0,"white");
    r.addColorStop(1,"transparent");
    g.fillStyle = r;
    g.fillRect(0,0,32,32);
    return new THREE.CanvasTexture(c);
}

const mat = new THREE.PointsMaterial({
    size: CONFIG.SIZE,
    map: sprite(),
    vertexColors: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    transparent: true
});

const points = new THREE.Points(geo, mat);
scene.add(points);

/* ================= SHAPES ================= */
function cloud() {
    const r = 18 * Math.cbrt(Math.random());
    const t = Math.random() * Math.PI * 2;
    const p = Math.acos(2 * Math.random() - 1);
    return {
        x: r * Math.sin(p) * Math.cos(t),
        y: r * Math.sin(p) * Math.sin(t),
        z: r * Math.cos(p)
    };
}

function heart(u, v) {
    const t = u * Math.PI * 2;
    return {
        x: 8 * Math.pow(Math.sin(t), 3),
        y: 5 * Math.cos(t) - 2 * Math.cos(2*t) - Math.cos(3*t),
        z: (v - 0.5) * 5
    };
}

/* ================= TARGET GENERATORS ================= */
function genCloud() {
    for (let i = 0; i < CONFIG.COUNT; i++) {
        const p = cloud();
        targetPos.set([p.x, p.y, p.z], i*3);
        targetCol.set(CONFIG.CLOUD_COLOR.toArray(), i*3);
    }
}

function genHeart() {
    for (let i = 0; i < CONFIG.COUNT; i++) {
        const p = heart(i / CONFIG.COUNT, Math.random());
        targetPos.set([p.x, p.y, p.z], i*3);
        targetCol.set(CONFIG.HEART_COLOR.toArray(), i*3);
    }
}

function genImage() {
    targetPos.set(state.imagePos);
    targetCol.set(state.imageCol);
}

/* ================= IMAGE PROCESS ================= */
function processImage(file) {
    const img = new Image();
    img.onload = () => {
        const h = 160;
        const w = Math.floor(160 * (img.width / img.height));

        const canvas = document.createElement("canvas");
        canvas.width = w;
        canvas.height = h;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0, w, h);

        const data = ctx.getImageData(0,0,w,h).data;
        let idx = 0;

        for (let y = 0; y < h && idx < CONFIG.COUNT; y++) {
            for (let x = 0; x < w && idx < CONFIG.COUNT; x++) {
                const i = (y*w + x) * 4;
                const r = data[i]/255, g = data[i+1]/255, b = data[i+2]/255, a = data[i+3];
                if (a < 128) continue;

                const lum = (r+g+b)/3;
                state.imagePos[idx*3] = (x - w/2)*0.15;
                state.imagePos[idx*3+1] = -(y - h/2)*0.15;
                state.imagePos[idx*3+2] = (lum - 0.5) * 8;

                state.imageCol.set([r,g,b], idx*3);
                idx++;
            }
        }

        for (; idx < CONFIG.COUNT; idx++) {
            state.imagePos[idx*3] = 999;
        }

        state.imageReady = true;
        setMode("image");
    };
    img.src = URL.createObjectURL(file);
}

/* ================= UI ================= */
const btnG = document.getElementById("btnGesture");
const btnI = document.getElementById("btnImage");
const fileInput = document.getElementById("fileInput");
const status = document.getElementById("status");

btnI.onclick = () => fileInput.click();
fileInput.onchange = e => processImage(e.target.files[0]);

btnG.onclick = () => setMode("gesture");

function setMode(m) {
    state.mode = m;
    btnG.classList.toggle("active", m==="gesture");
    btnI.classList.toggle("active", m==="image");
    document.getElementById("modeTitle").innerText = m==="gesture" ? "Gesture Mode" : "Image Mode";
    document.getElementById("modeDesc").innerText = m==="gesture" ? "Make a ðŸ«¶ heart" : "Image reconstructed";

    if (m === "image") genImage();
    else genCloud();
}

/* ================= MEDIAPIPE ================= */
const hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
hands.setOptions({ maxNumHands: 2, modelComplexity: 1 });

hands.onResults(r => {
    if (state.mode !== "gesture") return;
    let detected = false;
    if (r.multiHandLandmarks?.length === 2) {
        const [a,b] = r.multiHandLandmarks;
        const d1 = Math.hypot(a[8].x - b[8].x, a[8].y - b[8].y);
        const d2 = Math.hypot(a[4].x - b[4].x, a[4].y - b[4].y);
        detected = d1 < 0.08 && d2 < 0.08;
    }
    if (detected !== state.heart) {
        state.heart = detected;
        detected ? genHeart() : genCloud();
        status.innerText = detected ? "â¤ï¸ Heart Detected" : "Hands separated";
    }
});

new Camera(document.querySelector(".input_video"), {
    onFrame: async () => hands.send({ image: document.querySelector(".input_video") }),
    width: 640, height: 480
}).start();

/* ================= ANIMATE ================= */
function animate() {
    requestAnimationFrame(animate);
    scene.rotation.y += 0.001;

    for (let i = 0; i < CONFIG.COUNT*3; i++) {
        pos[i] += (targetPos[i] - pos[i]) * CONFIG.LERP;
        col[i] += (targetCol[i] - col[i]) * 0.05;
    }

    geo.attributes.position.needsUpdate = true;
    geo.attributes.color.needsUpdate = true;
    renderer.render(scene, camera);
}

genCloud();
animate();

window.onresize = () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
};
</script>
</body>
</html>
