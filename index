<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled Heart</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        .input_video { display: none; }
        
        #ui-overlay {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            pointer-events: none;
            z-index: 10;
        }
        
        h1 { margin: 0; font-weight: 300; letter-spacing: 2px; text-transform: uppercase; font-size: 1.2rem; }
        p { font-size: 0.9rem; margin-top: 5px; }
        .highlight { color: #ff4757; font-weight: bold; }
        
        #gesture-status {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: rgba(20, 20, 20, 0.8);
            border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #aaa;
            font-size: 0.8rem;
            transition: all 0.3s;
        }
        #gesture-status.active {
            background: rgba(255, 71, 87, 0.2);
            color: #ff4757;
            border-color: #ff4757;
            box-shadow: 0 0 15px rgba(255, 71, 87, 0.3);
        }
    </style>
    
    <!-- MediaPipe & Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>

    <video class="input_video"></video>
    
    <div id="gesture-status">waiting for hands...</div>

    <div id="ui-overlay">
        <h1>Magic Particles</h1>
        <p>Make a <span class="highlight">Heart Shape ðŸ«¶</span> with two hands to reveal the form.</p>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- Configuration ---
        const CONFIG = {
            particleCount: 20000,
            baseSize: 0.12,
            lerpSpeed: 0.12,
            heartColor: new THREE.Color(0xff0044),
            cloudColor: new THREE.Color(0x00aaff)
        };

        // State
        let isHeartGesture = false;
        let targetShape = 'cloud'; // 'cloud' or 'heart'

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- Texture ---
        function createSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'white');
            grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(canvas);
        }

        // --- Particles ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.particleCount * 3);
        const targetPositions = new Float32Array(CONFIG.particleCount * 3); // Where they want to go
        const colors = new Float32Array(CONFIG.particleCount * 3);
        
        // Init random positions
        for(let i=0; i<CONFIG.particleCount*3; i++) {
            positions[i] = (Math.random()-0.5) * 50;
            colors[i] = 1; 
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: CONFIG.baseSize,
            map: createSprite(),
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- Shape Generators ---
        function getHeartPoint(u, v) {
            // Parametric Heart
            const r = 10; // Scale
            // 0 <= t <= 2PI
            const t = u * Math.PI * 2;
            
            // Heart curve equation
            let x = 16 * Math.pow(Math.sin(t), 3);
            let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            
            // Add some depth (thickness)
            let z = (v - 0.5) * 5; 

            // Scale down
            return { x: x * 0.5, y: y * 0.5, z: z };
        }

        function getCloudPoint() {
            // Random sphere/cloud
            const r = 15 * Math.cbrt(Math.random()); // Even distribution in sphere
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            return {
                x: r * Math.sin(phi) * Math.cos(theta),
                y: r * Math.sin(phi) * Math.sin(theta),
                z: r * Math.cos(phi)
            };
        }

        // Update Target Positions based on current state
        function updateFormation() {
            const positionsArr = geometry.attributes.position.array;
            const colorsArr = geometry.attributes.color.array;
            
            const targetColor = isHeartGesture ? CONFIG.heartColor : CONFIG.cloudColor;

            for(let i=0; i<CONFIG.particleCount; i++) {
                let p;
                
                if (isHeartGesture) {
                    // HEART SHAPE
                    p = getHeartPoint(Math.random(), Math.random());
                    // Add slight jitter
                    p.x += (Math.random()-0.5)*0.5;
                    p.y += (Math.random()-0.5)*0.5;
                    p.z += (Math.random()-0.5)*0.5;
                } else {
                    // CLOUD SHAPE
                    p = getCloudPoint();
                    // Expand cloud slightly if idle
                    p.x *= 1.5; p.y *= 1.5; p.z *= 1.5;
                }

                targetPositions[i*3] = p.x;
                targetPositions[i*3+1] = p.y;
                targetPositions[i*3+2] = p.z;

                // Color Lerp (handled in animation loop usually, but simplistic here)
                // We'll just set target color in animation
            }
        }
        
        // --- MediaPipe Handling ---
        const statusDiv = document.getElementById('gesture-status');

        function onResults(results) {
            let detected = false;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length === 2) {
                // We need 2 hands
                const h1 = results.multiHandLandmarks[0];
                const h2 = results.multiHandLandmarks[1];

                // Landmark 8 = Index Tip, Landmark 4 = Thumb Tip
                const indexDist = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
                const thumbDist = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);

                // Threshold for "Touching"
                // Coordinates are normalized 0-1. 0.05 is roughly 5% of screen width proximity
                if (indexDist < 0.08 && thumbDist < 0.08) {
                    detected = true;
                }
            }

            // State Change Detection
            if (detected !== isHeartGesture) {
                isHeartGesture = detected;
                updateFormation(); // Recalculate targets immediately
                
                if(isHeartGesture) {
                    statusDiv.innerText = "HEART DETECTED â¤ï¸";
                    statusDiv.classList.add('active');
                } else {
                    statusDiv.innerText = "Hands separated";
                    statusDiv.classList.remove('active');
                }
            } else if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                 statusDiv.innerText = "Show both hands";
                 statusDiv.classList.remove('active');
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        const video = document.getElementsByClassName('input_video')[0];
        const cameraUtils = new Camera(video, {
            onFrame: async () => { await hands.send({image: video}); },
            width: 640, height: 480
        });
        cameraUtils.start();

        // --- Animation Loop ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            
            const positionsArr = geometry.attributes.position.array;
            const colorsArr = geometry.attributes.color.array;

            // Rotate entire system slowly
            scene.rotation.y = time * 0.1;

            const tColor = isHeartGesture ? CONFIG.heartColor : CONFIG.cloudColor;
            
            // Iterate Particles
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const px = i*3, py = i*3+1, pz = i*3+2;

                // Move Pos -> Target
                positionsArr[px] += (targetPositions[px] - positionsArr[px]) * CONFIG.lerpSpeed;
                positionsArr[py] += (targetPositions[py] - positionsArr[py]) * CONFIG.lerpSpeed;
                positionsArr[pz] += (targetPositions[pz] - positionsArr[pz]) * CONFIG.lerpSpeed;

                // Pulse effect if heart
                if (isHeartGesture) {
                    // Heartbeat math
                    const beat = 1 + Math.sin(time * 10) * 0.05 * Math.pow(Math.sin(time*10), 4); 
                    // Note: This applies uniform scale relative to origin, simplistic heartbeat
                    // Applying directly to position array is expensive to do correctly every frame with lerp fighting it.
                    // Instead, we just let the lerp handle shape, maybe modify lerp speed slightly or add noise.
                } else {
                    // Idle noise
                    positionsArr[px] += Math.sin(time + positionsArr[py]) * 0.01;
                }

                // Color blending
                colorsArr[px] += (tColor.r - colorsArr[px]) * 0.05;
                colorsArr[py] += (tColor.g - colorsArr[py]) * 0.05;
                colorsArr[pz] += (tColor.b - colorsArr[pz]) * 0.05;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            
            renderer.render(scene, camera);
        }

        // Initialize Cloud
        updateFormation();
        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
